import os
import ssl
import logging
import time
from ldap3 import Server, Connection, Tls, SUBTREE, MODIFY_REPLACE
from ldap3.core.exceptions import LDAPException, LDAPBindError
from datetime import datetime, timedelta, timezone
from dotenv import load_dotenv
from web_interface.utils import log_event

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# === FUNCIONES EXISTENTES (no modificadas) ===

def authenticate_user(username: str, password: str) -> bool:
    try:
        config = get_ad_config()
        server = Server(config['host'], port=config['port'], use_ssl=config['use_ssl'])
        conn = Connection(
            server,
            user=f"{config['user']}",
            password=config['password'],
            auto_bind=True
        )
        success = conn.rebind(user=f"{username}@{os.getenv('AD_DOMAIN')}", password=password)
        conn.unbind()
        log_event(level='INFO' if success else 'WARNING',
                  message=f"{'Éxito' if success else 'Fallo'} al autenticar a {username} en AD",
                  source='ad_connector')
        return success
    except Exception as e:
        logger.error(f"Error en authenticate_user: {str(e)}")
        return False

def get_ad_config():
    """Devuelve la configuración básica de AD desde variables de entorno."""
    return {
        'host': os.getenv('AD_SERVER'),
        'port': int(os.getenv('AD_PORT', 636)),
        'use_ssl': os.getenv('AD_USE_SSL', 'true').lower() == 'true',
        'user': os.getenv('AD_USER'),
        'password': os.getenv('AD_PASSWORD'),
        'search_base': os.getenv('AD_SEARCH_BASE'),
    }

def cambiar_password_usuario(email: str, new_password: str) -> dict:
    """
    Cambia la contraseña para el usuario identificado por su email.
    Se busca el DN del usuario mediante el filtro basado en el campo 'mail'.
    Si se encuentra el usuario, se intenta cambiar la contraseña (atributo 'unicodePwd')
    utilizando una conexión segura, tal como lo requiere AD.
    """
    try:
        logger.info(f"Cambiando contraseña para el usuario con email: {email}")
        config = get_ad_config()
        logger.info(f"Conectando al servidor AD en {config['host']}:{config['port']} (SSL: {config['use_ssl']})")

        # Crear el objeto Server. Si se requiere conexión segura, usar LDAPS.
        if config['use_ssl']:
            server = Server(config['host'], port=config['port'], use_ssl=True, tls=config['tls_config'])
        else:
            # Opción alternativa: usar StartTLS si no se usa SSL directamente.
            server = Server(config['host'], port=config['port'], use_ssl=False)

        conn = Connection(server,
                          user=config['user'],
                          password=config['password'],
                          auto_bind=True,
                          receive_timeout=30)

        if not conn.bound:
            logger.error(f"No se pudo conectar al AD. Razón: {conn.result}")
            return {"success": False, "message": "No se pudo conectar al Active Directory."}

        # Si no se usa SSL, podrías probar a iniciar TLS. Ejemplo:
        if not config['use_ssl']:
            if not conn.start_tls():
                logger.error("No se pudo iniciar StartTLS en la conexión.")
                return {"success": False, "message": "StartTLS falló. Conexión no segura para cambiar contraseña."}

        logger.info("Conexión con el AD establecida correctamente para cambiar contraseña.")

        # Buscar el usuario por el campo mail.
        search_filter = f"(&(objectClass=user)(mail={email}))"
        conn.search(
            search_base=config['search_base'],
            search_filter=search_filter,
            search_scope=SUBTREE,
            attributes=['distinguishedName']
        )
        if not conn.entries:
            logger.error("No se encontró el usuario en AD con el email proporcionado.")
            conn.unbind()
            return {"success": False, "message": "Usuario no encontrado en Active Directory."}

        user_dn = conn.entries[0].entry_dn
        logger.info(f"DN encontrado para el usuario: {user_dn[:30]}...")

        password_value = ('"' + new_password + '"').encode('utf-16-le')
        modify_password = {'unicodePwd': [(MODIFY_REPLACE, [password_value])]}

        conn.modify(user_dn, modify_password)
        if conn.result.get('result') == 0:
            logger.info("Contraseña cambiada exitosamente en el servidor AD.")
            result = {"success": True, "message": "La contraseña fue cambiada exitosamente."}
        else:
            logger.error(f"Error al cambiar contraseña: {conn.result}")
            result = {"success": False,
                      "message": f"El cambio de contraseña falló. Razón: {conn.result.get('description', 'N/A')}, Mensaje: {conn.result.get('message', 'N/A')}"}
        conn.unbind()
        logger.info("Conexión LDAP cerrada.")
        return result

    except LDAPBindError as e:
        logger.error(f"Error al autenticar contra el LDAP: {e}")
        return {"success": False, "message": "Error al autenticar contra el AD."}
    except LDAPException as e:
        logger.error(f"Error en la operación LDAP: {e}")
        return {"success": False, "message": f"Error en la operación LDAP: {e}"}
    except Exception as e:
        logger.error(f"Error inesperado: {e}")
        return {"success": False, "message": f"Error inesperado: {e}"}




def fetch_ad_users(retries=3):
    """Obtiene todos los usuarios del AD."""
    config = get_ad_config()
    server = Server(config['host'], port=config['port'], use_ssl=config['use_ssl'])
    users = []
    for attempt in range(1, retries + 1):
        try:
            logger.info(f"Intento {attempt} de conexión con {config['host']}:{config['port']}")
            with Connection(
                server,
                user=f"{config['user']}",
                password=config['password'],
                auto_bind=True
            ) as conn:
                conn.search(
                    search_base=config['search_base'],
                    search_filter='(objectClass=user)',
                    search_scope=SUBTREE,
                    attributes=['sAMAccountName', 'givenName', 'sn', 'mail', 'telephoneNumber', 'displayName']
                )
                for entry in conn.entries:
                    users.append({
                        'sAMAccountName': entry.sAMAccountName.value if entry.sAMAccountName else '',
                        'givenName': entry.givenName.value if entry.givenName else '',
                        'sn': entry.sn.value if entry.sn else '',
                        'mail': entry.mail.value if entry.mail else '',
                        'telephoneNumber': entry.telephoneNumber.value if entry.telephoneNumber else '',
                        'displayName': entry.displayName.value if entry.displayName else ''
                    })
                logger.debug(f"Conexión establecida: {conn.bound}")
                logger.info(f"Usuarios encontrados: {len(users)}")
                break
        except Exception as e:
            logger.error(f"Error en intento {attempt}: {str(e)}")
            if attempt == retries:
                raise
            time.sleep(2)
    return users

def check_group_membership(email_or_username):
    """Verifica si un usuario pertenece al grupo de administradores."""
    try:
        config = get_ad_config()
        server = Server(config['host'], port=config['port'], use_ssl=config['use_ssl'])
        with Connection(
            server,
            user=f"{config['user']}",
            password=config['password'],
            auto_bind=True
        ) as conn:
            if '@' in email_or_username:
                username = email_or_username.split('@')[0]
            else:
                username = email_or_username
            group_dn = os.getenv('AD_GROUP')
            if not group_dn:
                return False
            search_filter = f"(&(objectClass=user)(sAMAccountName={username})(memberOf:1.2.840.113556.1.4.1941:={group_dn}))"
            conn.search(
                search_base=os.getenv('AD_SEARCH_BASE'),
                search_filter=search_filter,
                attributes=['sAMAccountName']
            )
            return len(conn.entries) > 0
    except Exception as e:
        logger.error(f"Error verificando pertenencia al grupo: {str(e)}")
        return False

def get_password_expiry(email: str) -> dict:
    """Obtiene la fecha de expiración de la contraseña de un usuario."""
    try:
        config = get_ad_config()
        server = Server(config['host'], port=config['port'], use_ssl=config['use_ssl'])
        with Connection(
            server,
            user=f"{config['user']}",
            password=config['password'],
            auto_bind=True
        ) as conn:
            conn.search(
                search_base=os.getenv('AD_SEARCH_BASE'),
                search_filter=f'(mail={email})',
                attributes=['pwdLastSet', 'msDS-UserPasswordExpiryTimeComputed']
            )
            if conn.entries:
                entry = conn.entries[0]
                expiry_time = entry['msDS-UserPasswordExpiryTimeComputed'].value
                if expiry_time != 0:
                    expiry_dt = datetime.fromtimestamp((expiry_time - 116444736000000000) / 10000000, tz=timezone.utc)
                    return {
                        'expires': True,
                        'date': expiry_dt,
                        'days_left': (expiry_dt - datetime.now(timezone.utc)).days
                    }
    except Exception as e:
        logger.error(f"Error obteniendo expiración de contraseña: {str(e)}")
    return {'expires': False, 'date': None, 'days_left': None}

def is_user_active(email: str) -> bool:
    """
    Verifica si un usuario está activo en Active Directory.
    :param email: Correo electrónico del usuario.
    :return: True si está activo, False en caso contrario.
    """
    try:
        config = get_ad_config()
        server = Server(config['host'], port=config['port'], use_ssl=config['use_ssl'])

        with Connection(server, user=config['user'], password=config['password'], auto_bind=True) as conn:
            search_filter = f"(&(objectClass=user)(mail={email}))"
            conn.search(
                search_base=config['search_base'],
                search_filter=search_filter,
                attributes=['userAccountControl'],
                search_scope=SUBTREE
            )

            if not conn.entries:
                return False  # Usuario no encontrado

            # Verificar el atributo `userAccountControl`
            user_control = int(conn.entries[0].userAccountControl.value)
            is_active = not (user_control & 2)  # Verifica si el bit de "deshabilitado" no está activo
            return is_active
    except LDAPException as e:
        logger.error(f"Error verificando estado del usuario en AD: {str(e)}")
        return False
    except Exception as e:
        logger.error(f"Error inesperado verificando estado del usuario: {str(e)}")
        return False

def is_user_active_in_ad(username: str) -> bool:
    """Verifica si un usuario está activo en AD."""
    try:
        config = get_ad_config()
        server = Server(config['host'], port=config['port'], use_ssl=config['use_ssl'])
        with Connection(
            server,
            user=f"{config['user']}",
            password=config['password'],
            auto_bind=True
        ) as conn:
            conn.search(
                search_base=os.getenv('AD_SEARCH_BASE'),
                search_filter=f'(sAMAccountName={username})',
                attributes=['userAccountControl']
            )
            if conn.entries:
                uac = conn.entries[0]['userAccountControl'].value
                return (uac & 2) == 0  # 2 = ACCOUNTDISABLE
    except Exception as e:
        logger.error(f"Error verificando estado del usuario: {str(e)}")
    return False

# === NUEVAS FUNCIONES CORREGIDAS ===

def get_ad_group_config():
    """Devuelve el DN del grupo de administradores desde .env"""
    return os.getenv("AD_GROUP")

def is_ad_admin_group_enabled():
    """Verifica si la autenticación por grupo de admin está habilitada."""
    from web_interface.models import AppSetting
    return AppSetting.get_bool('AD_ADMIN_GROUP_AUTH', False)

def fetch_ad_users_for_import():
    """Obtiene todos los usuarios del AD, con sAMAccountName como username."""
    users = fetch_ad_users()
    result = []
    for user in users:
        try:
            username = user.get('sAMAccountName') or user.get('username')
            if not username:
                continue
            result.append({
                'username': username,
                'first_name': user.get('givenName', ''),
                'last_name': user.get('sn', ''),
                'email': user.get('mail', ''),
                'name': f"{user.get('givenName', '')} {user.get('sn', '')}".strip() or username
            })
        except Exception as e:
            logger.warning(f"Error procesando usuario: {e}")
            continue
    return result

def get_users_in_ad_group():
    """Obtiene directamente los usuarios del grupo AD usando el atributo 'member'."""
    try:
        config = get_ad_config()
        group_dn = os.getenv('AD_GROUP')
        if not group_dn:
            raise ValueError("AD_GROUP no está configurado en .env")

        server = Server(config['host'], port=config['port'], use_ssl=config['use_ssl'])
        with Connection(
            server,
            user=f"{config['user']}",
            password=config['password'],
            auto_bind=True
        ) as conn:
            conn.search(
                search_base=group_dn,
                search_filter='(objectClass=group)',
                attributes=['member']
            )

            if not conn.entries:
                logger.warning(f"No se encontró el grupo AD: {group_dn}")
                return []

            members_dn = conn.entries[0]['member'].values if 'member' in conn.entries[0] else []
            users = []

            for member_dn in members_dn:
                conn.search(
                    search_base=member_dn,
                    search_filter='(objectClass=user)',
                    attributes=['sAMAccountName', 'givenName', 'sn', 'mail']
                )
                if conn.entries:
                    entry = conn.entries[0]
                    users.append({
                        'username': entry.sAMAccountName.value if entry.sAMAccountName else '',
                        'first_name': entry.givenName.value if entry.givenName else '',
                        'last_name': entry.sn.value if entry.sn else '',
                        'email': entry.mail.value if entry.mail else ''
                    })
            return users

    except Exception as e:
        logger.error(f"Error obteniendo usuarios del grupo AD: {str(e)}")
        return []