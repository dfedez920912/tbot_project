from datetime import datetime, timedelta
from decouple import config
import re
import logging
import os
import json
import asyncio
from pathlib import Path
from asgiref.sync import sync_to_async
from django.utils import timezone
from telegram import (
    Update,
    ReplyKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardRemove,
    InlineKeyboardButton,
    InlineKeyboardMarkup
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    CallbackQueryHandler,
    ConversationHandler
)
from telegram_bot.models import Session


# Importar funciones de la base de datos y AD
from db_handler.db_handler import get_user_by_phone, delete_session
from ad_connector.ad_operations import (
    check_group_membership,
    get_password_expiry,
    cambiar_password_usuario,
    is_user_active
)
# Importar funciones de email
from email_service.email_sender import (
    notificar_cambio_contrasena_usuario,
    notificar_cambio_contrasena_admin
)

from web_interface.utils import log_event



# Ruta al archivo de mensajes
MESSAGES_FILE = Path(__file__).parent / "messages.json"

# Cargar mensajes
def load_messages():
    if MESSAGES_FILE.exists():
        with open(MESSAGES_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}

messages = load_messages()


def handle_password_change(user_id, username):
    try:
        # ... l√≥gica de cambio de contrase√±a
        log_event('INFO',f"Usuario {user_id} solicit√≥ cambio de contrase√±a para {username}",'telegram_bot')
        return True
    except Exception as e:
        log_event('ERROR',f"Error al cambiar contrase√±a para {username}: {str(e)}",'telegram_bot')
        return False

# Configurar logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Estados para los ConversationHandlers
# Flujo para cambiar la propia contrase√±a
GET_NEW_PASSWORD = 2
GET_PASSWORD_CONFIRMATION = 3
# Flujo para cambiar la contrase√±a de otro usuario (administrador)
GET_USER_EMAIL = 10
GET_USER_NEW_PASSWORD = 11
GET_USER_PASSWORD_CONFIRMATION = 12
# Flujo para verificar vigencia de otro usuario
GET_EMAIL = 1

# Duraci√≥n de la sesi√≥n en minutos (definida en .env, por defecto 30)
SESSION_DURATION = int(os.getenv("SESSION_DURATION"))

def get_greeting():
    """Devuelve el saludo seg√∫n la hora actual."""
    hour = datetime.now().hour
    if 5 <= hour < 12:
        return "¬°Buenos d√≠as! üåÖ"
    elif 12 <= hour < 19:
        return "¬°Buenas tardes! ‚òÄÔ∏è"
    else:
        return "¬°Buenas noches! üåô"

# -------------------- Funci√≥n: escape_markdown_v2 ----------------------- #
def escape_markdown_v2(text: str) -> str:
    """Escapa caracteres seg√∫n la especificaci√≥n de Markdown V2 para Telegram."""
    escape_chars = r"_*\[\]()~`>#+-=|{}.!\\"
    return re.sub(rf'([{re.escape(escape_chars)}])', r'\\\1', text)


# ---------------- Funciones de sesi√≥n ------------------
async def verify_session(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    try:
        user = update.effective_user
        session = await sync_to_async(Session.objects.get)(session_id=str(user.id))
        now = timezone.now()
        if now > session.last_updated:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=messages.get("session_expiry","Tu sesi√≥n ha expirado. üôè Por favor, autent√≠cate nuevamente aqu√≠: [Autenticar](https://t.me/INCA_PASS_BOT?start=start)"),
                parse_mode="Markdown"
            )
            return False
        else:
            # Actualizar el campo `last_updated` si la sesi√≥n sigue activa
            session.last_updated = timezone.now() + timedelta(minutes=SESSION_DURATION)
            await sync_to_async(session.save)()
            return True
    except Session.DoesNotExist:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=messages.get("session_inactive","‚ùå No tienes una sesi√≥n activa. Por favor, inicia sesi√≥n [/start - üöÄ Iniciar Bot]"),
            parse_mode="Markdown"
        )
        return False
    except Exception as e:
        log_event('ERROR', "Error verificando la sesi√≥n: %s", 'telegram_bot')
        return False

async def terminate_bot(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cierra la sesi√≥n del usuario y elimina el registro."""
    try:
        user_id = str(update.effective_user.id)

        # Llamar directamente a la funci√≥n as√≠ncrona delete_session
        deleted_count = await delete_session(user_id)

        if deleted_count > 0:
            log_event('INFO', "Sesi√≥n eliminada para el usuario {user_id}", 'telegram_bot')
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=messages.get("bot_terminated","ü§ñ Sesi√≥n terminada. ¬°Hasta pronto!")
            )
        else:
            log_event('WARNING', "No se encontr√≥ una sesi√≥n activa para el usuario {user_id}", 'telegram_bot')
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=messages.get("error_session_inactive","‚ö†Ô∏è No se encontr√≥ una sesi√≥n activa para cerrar. Si es un error, intenta autentic√°ndote nuevamente.")
            )

    except Exception as e:
        log_event('ERROR', "Error terminando la sesi√≥n para el usuario {update.effective_user.id}: {str(e)}", 'telegram_bot')
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=messages.get("error_session_contact","‚ö†Ô∏è Hubo un error inesperado al terminar tu sesi√≥n. Por favor, contacta al administrador.")
        )

async def handle_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Valida el contacto del usuario, verifica AD y crea la sesi√≥n."""
    contact = update.message.contact

    # Validar que el contacto corresponde al usuario
    if update.effective_user.id != contact.user_id:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=messages.get("user_contact_invalid","‚ö†Ô∏è El contacto compartido no corresponde a tu usuario de Telegram. Int√©ntalo de nuevo.")
        )
        return

    raw_phone = contact.phone_number.lstrip('+')
    user_id = contact.user_id

    try:
        # Buscar usuario por tel√©fono en la base de datos
        usuario = await get_user_by_phone(raw_phone)
        if not usuario:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=messages.get("user_not_found","‚ùå No se encontr√≥ el usuario en el sistema.")
            )
            return

        # Verificar si el usuario est√° activo en AD
        is_active = await sync_to_async(is_user_active)(usuario['mail'])
        if not is_active:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=messages.get("user_disabled","‚ùå Tu cuenta est√° deshabilitada en Active Directory. Contacta al administrador.")
            )
            return

        # Verificar si el usuario pertenece al grupo permitido
        is_member = await sync_to_async(check_group_membership)(usuario['mail'])

        # Crear la sesi√≥n despu√©s de todas las verificaciones exitosas
        await sync_to_async(Session.objects.update_or_create)(
            session_id=str(user_id),
            defaults={
                'email': usuario['mail'],
                'session_data': usuario['name'],
                'created_at': timezone.now(),
                'last_updated': timezone.now() + timedelta(minutes=SESSION_DURATION)
            }
        )

        # Construir las botoneras y enviarlas al usuario
        keyboard = [
            [InlineKeyboardButton("üîê Verificar vigencia", callback_data="check_expiry"),
             InlineKeyboardButton("üîÑ Cambiar contrase√±a üîë", callback_data="change_password")]
        ]
        if is_member:
            keyboard += [
                [InlineKeyboardButton("üîê Verificar a usuario üë§", callback_data="check_user_expiry"),
                 InlineKeyboardButton("üîÑ Cambiar a usuario üîëüë§", callback_data="change_user_password")]
            ]
        keyboard.append([InlineKeyboardButton("‚ùå Terminar bot ü§ñ", callback_data="terminar_bot")])
        reply_markup = InlineKeyboardMarkup(keyboard)


        message_text = messages.get("start_success","üë§ : {usuario['name']}\nüìß : {usuario['mail']}\n\n‚úÖ Autenticaci√≥n exitosa.")
        message_text = message_text.format(name=usuario['name'], email=usuario['mail'])    
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=message_text,
            reply_markup=reply_markup
        )

    except Exception as e:
        log_event('ERROR', "Error autenticando al usuario {user_id}: {str(e)}", 'telegram_bot')
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=messages.get("start_error","‚ö†Ô∏è Hubo un error durante la autenticaci√≥n. Int√©ntalo de nuevo m√°s tarde.")
        )

# --------------------- Flujo para cambiar la propia contrase√±a ---------------------
async def start_change_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await verify_session(update, context):
        return ConversationHandler.END
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=messages.get("change_password_reuqest","üôè Por favor, introduce tu nueva contrase√±a:")
    )
    return GET_NEW_PASSWORD

async def process_new_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        new_password = update.message.text.strip()
        chat_id = update.message.chat_id
        # Borrar el mensaje con la nueva contrase√±a del usuario (para no dejar datos sensibles)
        await update.message.delete()
        context.user_data['new_password'] = new_password
        await context.bot.send_message(chat_id=chat_id, text=messages.get("password_confirmation_request","üôè Por favor, confirma tu nueva contrase√±a:"))
        return GET_PASSWORD_CONFIRMATION
    except Exception as e:
        log_event('EXCEPTION', "Error en process_new_password: %s", 'telegram_bot')
        await context.bot.send_message(chat_id=chat_id, text=messages.get("error_processing","‚ö†Ô∏è Ocurri√≥ un error. Int√©ntalo nuevamente."))
        return ConversationHandler.END

async def process_password_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        confirmation = update.message.text.strip()
        chat_id = update.message.chat_id
        await update.message.delete()

        new_password = context.user_data.get('new_password')
        if not new_password:
            await context.bot.send_message(
                chat_id=chat_id,
                text=messages.get("initial_password_error", "‚ö†Ô∏è No se recibi√≥ la contrase√±a inicial. Int√©ntalo de nuevo.")
            )
            return ConversationHandler.END

        if new_password != confirmation:
            await context.bot.send_message(
                chat_id=chat_id,
                text=messages.get("passwords_not_match", "‚ö†Ô∏è Las contrase√±as no coinciden. Int√©ntalo de nuevo.")
            )
            # ‚Üê Eliminar la contrase√±a guardada
            context.user_data.pop('new_password', None)
            # ‚Üê Volver a solicitar nueva contrase√±a
            await context.bot.send_message(
                chat_id=chat_id,
                text=messages.get("change_password_request", "üôè Por favor, introduce tu nueva contrase√±a:")
            )
            return GET_NEW_PASSWORD

        # ‚Üê Si coinciden, cambiar la contrase√±a
        session = await sync_to_async(Session.objects.get)(session_id=str(chat_id))
        email = session.email
        if not email:
            await context.bot.send_message(
                chat_id=chat_id,
                text=messages.get("user_email_invalid", "‚ùå No tienes un email asociado. Inicia sesi√≥n nuevamente.")
            )
            return ConversationHandler.END

        result = await sync_to_async(cambiar_password_usuario)(email, new_password)
        if result["success"]:
            await context.bot.send_message(
                chat_id=chat_id,
                text=messages.get("password_changed_success", "‚úÖ La contrase√±a fue cambiada exitosamente.")
            )
            # Notificar v√≠a email
            notificar_cambio_contrasena_usuario(email, new_password)
            # Notificar a admins
            admin_emails_str = config('ADMIN_EMAILS', default='')
            admin_emails = [e.strip() for e in admin_emails_str.split(",") if e.strip()]
            if admin_emails:
                notificar_cambio_contrasena_admin(admin_emails, email)
            # Limpiar datos
            context.user_data.clear()
            return ConversationHandler.END
        else:
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"‚ö†Ô∏è Error al cambiar contrase√±a: {result['message']}"
            )
            return ConversationHandler.END

    except Exception as e:
        log_event('ERROR', f"Error en process_password_confirmation: {str(e)}", 'telegram_bot')
        await context.bot.send_message(
            chat_id=chat_id,
            text=messages.get("error_processing", "‚ö†Ô∏è Ocurri√≥ un error. Int√©ntalo nuevamente.")
        )
        # ‚Üê Limpiar datos en caso de error
        context.user_data.clear()
        return ConversationHandler.END
    
# ----------------- Flujo para cambiar la contrase√±a de otro usuario (administrador) -----------------
async def start_change_user_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await verify_session(update, context):
        return ConversationHandler.END
    try:
        user = update.effective_user
        session = await sync_to_async(Session.objects.get)(session_id=str(user.id))
        if not await sync_to_async(check_group_membership)(session.email):
            await context.bot.send_message(chat_id=update.effective_chat.id, text=messages.get("invalid_access", "‚ùå Acceso restringido: Solo para administradores."))
            return ConversationHandler.END
    except Exception as e:
        await context.bot.send_message(chat_id=update.effective_chat.id, text=messages.get("internal_error","‚ùå Error interno. Contacte al administrador."))
        return ConversationHandler.END
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=messages.get("admin_password_email_request","üôè Por favor, introduce el email del usuario al que deseas cambiar la contrase√±a:")
    )
    return GET_USER_EMAIL

async def process_user_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        target_email = update.message.text.strip().lower()
        chat_id = update.message.chat_id
        if not re.match(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", target_email):
            await context.bot.send_message(chat_id=chat_id, text=messages.get("user_email_invalid","‚ùå El formato del email no es v√°lido. Int√©ntalo de nuevo:"))
            return GET_USER_EMAIL
        context.user_data['target_email'] = target_email
        await context.bot.send_message(
    chat_id=chat_id,
    text=messages.get(
        "change_password_request",  # ‚Üê Clave del mensaje
        f"üîç Se proceder√° a cambiar la contrase√±a para {target_email}. üôè Por favor, introduce la nueva contrase√±a:"
    )
)
        return GET_USER_NEW_PASSWORD
    except Exception as e:
        log_event('EXCEPTION', "Error en process_user_email: %s", 'telegram_bot')
        await context.bot.send_message(chat_id=update.effective_chat.id, text=messages.get("error_processing","‚ö†Ô∏è Ocurri√≥ un error. Int√©ntalo nuevamente."))
        return ConversationHandler.END

async def process_user_new_password(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        new_password = update.message.text.strip()
        chat_id = update.message.chat_id
        await update.message.delete()
        context.user_data['target_new_password'] = new_password
        await context.bot.send_message(chat_id=chat_id, text=messages.get("change_password_reuqest","üôè Por favor, confirma la nueva contrase√±a:"))
        return GET_USER_PASSWORD_CONFIRMATION
    except Exception as e:
        log_event('EXCEPTION', "Error en process_user_new_password: %s", 'telegram_bot')
        await context.bot.send_message(chat_id=update.effective_chat.id, text=messages.get("error_processing","‚ö†Ô∏è Ocurri√≥ un error. Int√©ntalo nuevamente."))
        return ConversationHandler.END

async def process_user_password_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        confirmation = update.message.text.strip()
        chat_id = update.message.chat_id
        await update.message.delete()
        new_password = context.user_data.get('target_new_password')
        target_email = context.user_data.get('target_email')
        if not new_password or not target_email:
            await context.bot.send_message(chat_id=chat_id, text=messages.get("data_error","‚ö†Ô∏è Datos insuficientes. Int√©ntalo de nuevo."))
            return ConversationHandler.END
        if new_password != confirmation:
            await context.bot.send_message(chat_id=chat_id, text=messages.get("password_not_match","‚ö†Ô∏è Las contrase√±as no coinciden. Int√©ntalo de nuevo."))
            return ConversationHandler.END
        result = await sync_to_async(cambiar_password_usuario)(target_email, new_password)
        if result["success"]:
            await context.bot.send_message(chat_id=chat_id,
                                           text=messages.get("admin_password_changed","‚úÖ La contrase√±a fue cambiada exitosamente para el usuario."))
            # Notificar al usuario afectado.
            notificar_cambio_contrasena_usuario(target_email, new_password)
            # Notificar a los administradores.
            admin_emails_str = config('ADMIN_EMAILS', default='')
            admin_emails = [e.strip() for e in admin_emails_str.split(",") if e.strip()]
            log_event('INFO', "Emails de administradores le√≠dos: {admin_emails}", 'telegram_bot')
            if admin_emails:
                notificar_cambio_contrasena_admin(admin_emails, target_email)
        else:
            await context.bot.send_message(chat_id=chat_id, text=messages.get(f"general_error",f"‚ö†Ô∏è Error: {result['message']}"))
    except Exception as e:
        log_event('EXCEPTION', "Error en process_user_password_confirmation: %s", 'telegram_bot')
        await context.bot.send_message(chat_id=chat_id, text=messages.get("password_confirmation_error","‚ö†Ô∏è Ocurri√≥ un error al procesar la confirmaci√≥n."))
    finally:
        context.user_data.clear()
        return ConversationHandler.END


# ----------------- Otros flujos (handle_contact, check_expiry, check_user_expiry, process_email) -----------------
async def check_user_expiry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Inicia el flujo para verificar la vigencia de otro usuario.
    Se solicita el email completo y se procesa con la misma estructura que para el propio usuario.
    """
    if not await verify_session(update, context):
        return

    try:
        query = update.callback_query
        await query.answer()
        log_event('INFO', "Inicio de check_user_expiry", 'telegram_bot')

        session = await sync_to_async(Session.objects.get)(session_id=str(query.from_user.id))
        log_event('DEBUG', "Sesi√≥n obtenida: {session.session_id}", 'telegram_bot')
        if not await sync_to_async(check_group_membership)(session.email):
            log_event('WARNING', "Intento de acceso no autorizado", 'telegram_bot')
            await context.bot.send_message(
                chat_id=query.message.chat_id,
                text=messages.get("error_access","‚ùå Acceso restringido: Solo para administradores")
            )
            return ConversationHandler.END

        log_event('INFO', "Solicitando email completo para verificaci√≥n de vigencia de otro usuario", 'telegram_bot')
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            text=messages.get("admin_password_fullemail_request","üôè Por favor, introduce el email completo del usuario:"),
            reply_markup=ReplyKeyboardRemove()
        )
        return GET_EMAIL

    except Exception as e:
        log_event('EXCEPTION', "Error en check_user_expiry:", 'telegram_bot')
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            text=messages.get("internal_error","‚ö†Ô∏è Error interno. Contacte al administrador.")
        )
        return ConversationHandler.END

async def process_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Recibe el email ingresado y lo env√≠a a get_password_expiry.
    La respuesta se construye con la misma estructura que en la verificaci√≥n del propio usuario.
    """
    if not await verify_session(update, context):
        return ConversationHandler.END

    try:
        if not update.message or not update.message.text:
            log_event('DEBUG', "No se recibi√≥ mensaje de texto en process_email", 'telegram_bot')
            await update.message.reply_text("üôè Por favor, introduce un email v√°lido.")
            return GET_EMAIL

        email = update.message.text.strip().lower()
        log_event('DEBUG', "Email recibido: %s {email}", 'telegram_bot')

        if not re.match(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", email):
            await update.message.reply_text("‚ùå El formato del email no es v√°lido. Int√©ntalo de nuevo:")
            return GET_EMAIL

        await update.message.reply_text(
            f"üîç Procesando vigencia de la contrase√±a para el email: {email}"
        )

        try:
            expiry_info = await sync_to_async(get_password_expiry, thread_sensitive=True)(email)
            log_event('DEBUG', "Resultado obtenido de get_password_expiry: %s {expiry_info}", 'telegram_bot')
        except Exception as e_inner:
            log_event('ERROR', "Error en consulta a AD: %s [str(e_inner)]", 'telegram_bot')
            await update.message.reply_text(
                "‚ö†Ô∏è Error al verificar la vigencia del email. Intenta nuevamente m√°s tarde."
            )
            return ConversationHandler.END

        if expiry_info['is_expired']:
            response = (
                f"üî¥ CONTRASE√ëA EXPIRADA\n"
                f"üìß Email: {email}\n"
                f"üóìÔ∏è Expir√≥ hace {-expiry_info['days_remaining']} d√≠as"
            )
        else:
            response = (
                f"üü¢ CONTRASE√ëA VIGENTE\n"
                f"üìß Email: {email}\n"
                f"üóìÔ∏è Expira: {expiry_info.get('expiry_date', 'N/A')}\n"
                f"‚åõ D√≠as restantes: {expiry_info.get('days_remaining', 'N/A')}"
            )

        log_event('INFO', "Enviando respuesta al usuario: %s {response}", 'telegram_bot')
        response_escaped = escape_markdown_v2(response)
        await update.message.reply_text(response_escaped, parse_mode="MarkdownV2")

    except Exception as e:
        log_event('EXCEPTION', "Error cr√≠tico en process_email:", 'telegram_bot')
        await update.message.reply_text("‚ö†Ô∏è Error procesando solicitud.")
    finally:
        context.user_data.clear()
        return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("‚ùå Operaci√≥n cancelada", reply_markup=ReplyKeyboardRemove())
    return ConversationHandler.END

async def check_expiry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await verify_session(update, context):
        return
    try:
        query = update.callback_query
        await query.answer()
        user = update.effective_user
        session = await sync_to_async(Session.objects.get)(session_id=str(user.id))
        email = session.email
        if not email:
            raise ValueError("üìß Email no registrado en sesi√≥n")
        expiry_info = await sync_to_async(get_password_expiry)(email)
        if expiry_info['error']:
            raise Exception(expiry_info['error'])
        if expiry_info['is_expired']:
            message = (f"üî¥ CONTRASE√ëA EXPIRADA\n"
                       f"üìß Email: {email}\n"
                       f"üóìÔ∏è Expir√≥ hace {-expiry_info['days_remaining']} d√≠as")
        else:
            message = (f"üü¢ CONTRASE√ëA VIGENTE\n"
                       f"üìß Email: {email}\n"
                       f"üóìÔ∏è Expira: {expiry_info['expiry_date']}\n"
                       f"‚åõ D√≠as restantes: {expiry_info['days_remaining']}")
        await context.bot.send_message(chat_id=query.message.chat_id, text=escape_markdown_v2(message), parse_mode='MarkdownV2')
    except Exception as e:
        log_event('ERROR', "Error en check_expiry: %s", 'telegram_bot')
        await context.bot.send_message(chat_id=update.effective_chat.id, text=messages.get(f"error_verifiying2", f"‚ö†Ô∏è Error al verificar: {str(e)}"))



async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Maneja el comando /start y autentica al usuario."""
    user = update.effective_user
    session_exists = await sync_to_async(Session.objects.filter(session_id=str(user.id)).exists)()

    # Si ya hay una sesi√≥n activa, aseg√∫rate de eliminarla o manejarla correctamente
    if session_exists:
        await sync_to_async(Session.objects.filter(session_id=str(user.id)).delete)()
        log_event('INFO', "Sesi√≥n previa eliminada para el usuario {user.id}", 'telegram_bot')



    greeting = get_greeting()
    # ‚Üê Crear un contexto con todas las variables
    contexts = {
        'g_greeting': greeting,
        'user_first_name': user.first_name
    }

    # ‚Üê Usar format_map con un dict
    message_template = messages.get(
        "start_session",
        "{g_greeting} {user_first_name}! üëã\n\nPara continuar, üôè comparte tu n√∫mero de contacto:"
    )
    message_text = message_template.format_map(contexts)
    
    # Solicitar al usuario compartir su contacto
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=message_text,
        reply_markup=ReplyKeyboardMarkup(
            [[KeyboardButton("Compartir contacto üì±", request_contact=True)]],
            resize_keyboard=True,
            one_time_keyboard=True
        )
    )


async def handle_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestiona las acciones de los botones inline."""
    query = update.callback_query
    await query.answer()

    action = query.data
    if action == "check_expiry":
        await check_expiry(update, context)
    elif action == "check_user_expiry":
        await check_user_expiry(update, context)
    elif action == "change_password":
        # El ConversationHandler de cambio de contrase√±a captar√° este callback.
        return
    elif action == "exit_bot":
        await terminate_bot(update, context)
    # Otros callbacks (p.ej.: "change_user_password") se podr√≠an configurar de forma similar.


def run_bot(token: str):
    application = ApplicationBuilder().token(token).build()

    application.add_handler(CommandHandler('start', start))
    application.add_handler(MessageHandler(filters.CONTACT, handle_contact))
    application.add_handler(CommandHandler('terminar_bot', terminate_bot))

    conv_handler_change = ConversationHandler(
        entry_points=[CallbackQueryHandler(start_change_password, pattern='^change_password$')],
        states={
            GET_NEW_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_new_password)],
            GET_PASSWORD_CONFIRMATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_password_confirmation)]
        },
        fallbacks=[CommandHandler('cancel', cancel)]
    )
    application.add_handler(conv_handler_change)

    conv_handler_change_user = ConversationHandler(
        entry_points=[CallbackQueryHandler(start_change_user_password, pattern='^change_user_password$')],
        states={
            GET_USER_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_user_email)],
            GET_USER_NEW_PASSWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_user_new_password)],
            GET_USER_PASSWORD_CONFIRMATION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, process_user_password_confirmation)]
        },
        fallbacks=[CommandHandler('cancel', cancel)]
    )
    application.add_handler(conv_handler_change_user)

    conv_handler_verify = ConversationHandler(
        entry_points=[CallbackQueryHandler(check_user_expiry, pattern='^check_user_expiry$')],
        states={GET_EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_email)]},
        fallbacks=[CommandHandler('cancel', cancel)]
    )
    application.add_handler(conv_handler_verify)

    # Agregar un handler para check_expiry: este se activa cuando se pulsa el bot√≥n "check_expiry"
    application.add_handler(CallbackQueryHandler(check_expiry, pattern='^check_expiry$'))
    # Luego, registra el handler para "exit_bot"
    application.add_handler(CallbackQueryHandler(terminate_bot, pattern='^terminar_bot$'))
    application.run_polling()


if __name__ == "__main__":
    TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "your_token_here")
    run_bot(TOKEN)
